---
summary: "연구 노트: Clawd 워크스페이스용 오프라인 메모리 시스템 (Markdown 정본 + 파생 인덱스)"
read_when:
  - 워크스페이스 메모리 설계 (~/.openclaw/workspace)와 일일 Markdown 로그 이상의 기능
  - 독립형 CLI 대 깊은 OpenClaw 통합 결정
  - 오프라인 회상 + 성찰 추가 (retain/recall/reflect)
title: "워크스페이스 메모리 연구"
---

# 워크스페이스 메모리 v2 (오프라인): 연구 노트

목표: Clawd 스타일의 워크스페이스 (`agents.defaults.workspace`, 기본값 `~/.openclaw/workspace`)에서 "메모리"를 일일 Markdown 파일 (`memory/YYYY-MM-DD.md`)과 안정적인 파일 집합 (예: `memory.md`, `SOUL.md`)으로 저장합니다.

이 문서는 Markdown을 정규 검토 가능 정보원으로 유지하면서 파생 인덱스를 통해 **구조화된 회상** (검색, 개체 요약, 신뢰도 업데이트)을 추가하는 **오프라인 우선** 메모리 아키텍처를 제안합니다.

## 변경 사유

현재 설정 (일일 파일)은 다음 측면에서 우수합니다:

- "추가 전용" 저널링
- 사람이 직접 편집
- Git 지원 내구성 + 감시 가능성
- 낮은 마찰 캡처 ("적어두기만 함")

하지만 다음 측면에서는 약합니다:

- 높은 회상 검색 ("X에 대해 무엇을 결정했나?", "마지막으로 Y를 시도했을 때는?")
- 개체 중심 답변 ("Alice / The Castle / warelay에 대해 알려주세요")은 많은 파일을 다시 읽어야 함
- 의견/선호도 안정성 (변경될 때의 증거)
- 시간 제약 ("2025년 11월에 무엇이 사실이었나?")과 충돌 해결

## 설계 목표

- **오프라인**: 네트워크 없이 작동; 랩톱/Castle에서 실행 가능; 클라우드 의존성 없음
- **설명 가능**: 검색된 항목은 귀속 가능하고 (파일 + 위치) 추론과 분리 가능해야 함
- **낮은 의식**: 일일 로깅은 Markdown으로 유지되며, 무거운 스키마 작업 불필요
- **점진적**: v1은 FTS만으로도 유용하며, 의미론적/벡터 및 그래프는 선택적 업그레이드
- **에이전트 친화적**: 토큰 예산 내에서 "회상"을 쉽게 만듦 (작은 사실 번들 반환)

## 북스타 모델 (Hindsight × Letta)

혼합할 두 가지 요소:

1. **Letta/MemGPT 스타일 제어 루프**

- 작은 "핵심"을 항상 컨텍스트에 유지 (개인 정보 + 주요 사용자 사실)
- 다른 모든 것은 컨텍스트 외부에 있으며 도구를 통해 검색됨
- 메모리 쓰기는 명시적 도구 호출 (추가/바꾸기/삽입), 지속됨, 다음 차례에 다시 주입됨

2. **Hindsight 스타일 메모리 기질**

- 관찰된 것 대 믿어지는 것 대 요약된 것 분리
- retain/recall/reflect 지원
- 증거와 함께 진화할 수 있는 신뢰도 있는 의견
- 개체 인식 검색 + 시간 쿼리 (전체 지식 그래프 없이도)

## 제안된 아키텍처 (Markdown 정본 + 파생 인덱스)

### 정규 저장소 (Git 친화적)

`~/.openclaw/workspace`를 정규 사람이 읽을 수 있는 메모리로 유지합니다.

제안된 워크스페이스 레이아웃:

```
~/.openclaw/workspace/
  memory.md                    # 작음: 내구적 사실 + 선호도 (핵심-ish)
  memory/
    YYYY-MM-DD.md              # 일일 로그 (추가; 서사)
  bank/                        # "입력된" 메모리 페이지 (안정적, 검토 가능)
    world.md                   # 세계에 대한 객관적 사실
    experience.md              # 에이전트가 한 일 (1인칭)
    opinions.md                # 주관적 선호도/판단 + 신뢰도 + 증거 포인터
    entities/
      Peter.md
      The-Castle.md
      warelay.md
      ...
```

주석:

- **일일 로그는 일일 로그로 유지됩니다**. JSON으로 변환할 필요가 없습니다.
- `bank/` 파일은 **큐레이션되며**, 성찰 작업으로 생성되며, 여전히 수동으로 편집할 수 있습니다.
- `memory.md`는 "작음 + 핵심-ish"으로 유지됩니다: Clawd가 매 세션마다 보고 싶어하는 것들.

### 파생 저장소 (기계 회상)

워크스페이스 아래에 파생 인덱스 추가 (반드시 Git 추적 대상이 아님):

```
~/.openclaw/workspace/.memory/index.sqlite
```

다음으로 지원합니다:

- 사실 + 개체 링크 + 의견 메타데이터용 SQLite 스키마
- 어휘적 회상용 SQLite **FTS5** (빠름, 작음, 오프라인)
- 의미론적 회상용 선택적 임베딩 테이블 (여전히 오프라인)

인덱스는 항상 **Markdown에서 재구성 가능합니다**.

## Retain / Recall / Reflect (운영 루프)

### Retain: 일일 로그를 "사실"로 정규화

Hindsight의 핵심 통찰은 여기서 중요합니다: 작은 조각이 아닌 **서사적, 자체 포함된 사실**을 저장합니다.

`memory/YYYY-MM-DD.md`에 대한 실질적 규칙:

- 하루 끝 (또는 도중)에 2-5개의 항목이 있는 `## Retain` 섹션 추가:
  - 서사적 (크로스턴 컨텍스트 보존)
  - 자체 포함 (나중에 독립 실행형이 말이 됨)
  - 유형 + 개체 언급으로 태그됨

예:

```
## Retain
- W @Peter: 현재 Andy 생일을 위해 마라케시에 있음 (11월 27일-12월 1일, 2025년).
- B @warelay: connection.update 핸들러를 try/catch로 감싸서 Baileys WS 크래시 수정함 (memory/2025-11-27.md 참조).
- O(c=0.95) @Peter: WhatsApp에서 간결한 회신 (<1500자) 선호; 긴 콘텐츠는 파일로 이동.
```

최소 파싱:

- 유형 접두사: `W` (세계), `B` (경험/전기), `O` (의견), `S` (관찰/요약; 보통 생성됨)
- 개체: `@Peter`, `@warelay` 등 (슬러그는 `bank/entities/*.md`로 매핑됨)
- 의견 신뢰도: `O(c=0.0..1.0)` 선택 사항

저자가 이에 대해 생각하기를 원하지 않는다면: 성찰 작업이 나머지 로그에서 이러한 항목을 유추할 수 있지만, 명시적 `## Retain` 섹션을 갖는 것이 가장 쉬운 "품질 레버"입니다.

### Recall: 파생 인덱스에 대한 쿼리

Recall은 다음을 지원해야 합니다:

- **어휘적**: "정확한 용어 / 이름 / 명령어 찾기" (FTS5)
- **개체**: "X에 대해 알려주세요" (개체 페이지 + 개체 연결 사실)
- **시간적**: "11월 27일경에 무엇이 일어났나" / "지난주 이후"
- **의견**: "Peter는 무엇을 선호하나?" (신뢰도 + 증거 포함)

반환 형식은 에이전트 친화적이고 출처를 인용해야 합니다:

- `kind` (`world|experience|opinion|observation`)
- `timestamp` (출처 날짜, 또는 현재인 경우 추출된 시간 범위)
- `entities` (`["Peter","warelay"]`)
- `content` (서사적 사실)
- `source` (`memory/2025-11-27.md#L12` 등)

### Reflect: 안정적 페이지 생성 + 신념 업데이트

성찰은 예약된 작업 (일일 또는 하트비트 `ultrathink`)으로:

- 최근 사실에서 `bank/entities/*.md` 업데이트 (개체 요약)
- 강화/모순을 기반으로 `bank/opinions.md` 신뢰도 업데이트
- 선택적으로 `memory.md`에 편집 제안 ("핵심-ish" 내구적 사실)

의견 진화 (단순, 설명 가능):

- 각 의견은 다음을 포함:
  - 진술
  - 신뢰도 `c ∈ [0,1]`
  - 마지막_업데이트
  - 증거 링크 (지지하는 + 모순되는 사실 ID)
- 새로운 사실이 도착하면:
  - 개체 중첩 + 유사성으로 후보 의견 찾기 (먼저 FTS, 나중에 임베딩)
  - 작은 델타로 신뢰도 업데이트; 큰 점프는 강한 모순 + 반복된 증거 필요

## CLI 통합: 독립형 대 깊은 통합

권장사항: **OpenClaw 내 깊은 통합**, 하지만 분리 가능한 핵심 라이브러리 유지.

### OpenClaw에 통합하는 이유?

- OpenClaw는 이미 알고 있습니다:
  - 워크스페이스 경로 (`agents.defaults.workspace`)
  - 세션 모델 + 하트비트
  - 로깅 + 문제 해결 패턴
- 에이전트 자체가 도구를 호출하기를 원합니다:
  - `openclaw memory recall "…" --k 25 --since 30d`
  - `openclaw memory reflect --since 7d`

### 왜 여전히 라이브러리를 분리하나?

- 게이트웨이/런타임 없이 메모리 로직을 테스트 가능하게 유지
- 다른 컨텍스트에서 재사용 (로컬 스크립트, 향후 데스크톱 앱 등)

형태:

메모리 도구는 작은 CLI + 라이브러리 계층으로 의도되었지만, 이는 탐색 전용입니다.

## "S-Collide" / SuCo: 사용 시기 (연구)

"S-Collide"가 **SuCo (Subspace Collision)**를 의미한다면: 부분공간에서 학습/구조화된 충돌을 사용하여 강한 회상/지연 시간 트레이드오프를 목표로 하는 ANN 검색 방법입니다 (논문: arXiv 2411.14754, 2024).

`~/.openclaw/workspace`에 대한 실용적 관점:

- **SuCo로 시작하지 마세요**.
- SQLite FTS + (선택적) 단순 임베딩으로 시작하면 대부분의 UX 이득을 즉시 얻습니다.
- SuCo/HNSW/ScaNN 클래스 솔루션은 다음 조건일 때만 고려하세요:
  - 코퍼스가 큼 (수만에서 수십만 청크)
  - 무차별 대입식 임베딩 검색이 너무 느려짐
  - 회상 품질이 의미 있게 어휘적 검색으로 인해 병목이 됨

오프라인 친화적 대안 (증가하는 복잡도):

- SQLite FTS5 + 메타데이터 필터 (ML 없음)
- 임베딩 + 무차별 대입식 (청크 수가 낮으면 놀랍도록 잘 작동)
- HNSW 인덱스 (일반적, 견고함; 라이브러리 바인딩 필요)
- SuCo (연구급; 포함할 수 있는 견고한 구현이 있으면 매력적)

미결정 질문:

- "개인 어시스턴트 메모리"용 **최고의** 오프라인 임베딩 모델은 무엇입니까 (랩톱 + 데스크톱)?
  - 이미 Ollama가 있다면: 로컬 모델로 임베딩; 그렇지 않으면 도구 체인에 작은 임베딩 모델 제공.

## 가장 작은 유용한 파일럿

최소한의 여전히 유용한 버전을 원한다면:

- `bank/` 개체 페이지 추가 및 일일 로그에 `## Retain` 섹션 추가.
- 인용문 (경로 + 줄 번호)과 함께 회상에 SQLite FTS 사용.
- 회상 품질 또는 규모가 요구하면 임베딩만 추가.

## 참고 자료

- Letta / MemGPT 개념: "핵심 메모리 블록" + "아카이브 메모리" + 도구 주도 자체 편집 메모리.
- Hindsight 기술 보고서: "retain / recall / reflect", 4-네트워크 메모리, 서사적 사실 추출, 의견 신뢰도 진화.
- SuCo: arXiv 2411.14754 (2024): "Subspace Collision" 근사 최근접 이웃 검색.
