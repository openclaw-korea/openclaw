---
summary: "게이트웨이 찾기를 위한 노드 디스커버리 및 전송 (Bonjour, Tailscale, SSH)"
read_when:
  - Bonjour 디스커버리/광고 구현 또는 변경
  - 원격 연결 모드 조정 (직접 vs SSH)
  - 원격 노드를 위한 노드 디스커버리 + 페어링 설계
title: "디스커버리 및 전송"
---

# 디스커버리 & 전송

OpenClaw는 표면상 유사해 보이는 두 가지 별개의 문제를 가지고 있습니다:

1. **운영자 원격 제어**: 다른 곳에서 실행 중인 게이트웨이를 제어하는 macOS 메뉴바 앱.
2. **노드 페어링**: 게이트웨이를 찾아 안전하게 페어링하는 iOS/Android (및 향후 노드).

설계 목표는 모든 네트워크 디스커버리/광고를 **노드 게이트웨이** (`openclaw gateway`)에 유지하고 클라이언트 (mac 앱, iOS)를 소비자로 유지하는 것입니다.

## 용어

- **게이트웨이**: 상태 (세션, 페어링, 노드 레지스트리)를 소유하고 채널을 실행하는 단일 장시간 실행 게이트웨이 프로세스입니다. 대부분의 설정은 호스트당 하나를 사용합니다. 격리된 다중 게이트웨이 설정도 가능합니다.
- **게이트웨이 WS (제어 평면)**: 기본적으로 `127.0.0.1:18789`의 WebSocket 엔드포인트. `gateway.bind`를 통해 LAN/tailnet에 바인딩할 수 있습니다.
- **직접 WS 전송**: LAN/tailnet 지향 게이트웨이 WS 엔드포인트 (SSH 없음).
- **SSH 전송 (대체)**: SSH를 통해 `127.0.0.1:18789`를 전달하여 원격 제어.
- **레거시 TCP 브리지 (더 이상 사용 안 함/제거됨)**: 이전 노드 전송 ([브리지 프로토콜](/gateway/bridge-protocol) 참조). 더 이상 디스커버리를 위해 광고되지 않습니다.

프로토콜 세부 정보:

- [게이트웨이 프로토콜](/gateway/protocol)
- [브리지 프로토콜 (레거시)](/gateway/bridge-protocol)

## "직접"과 SSH를 모두 유지하는 이유

- **직접 WS**는 동일한 네트워크 및 tailnet 내에서 최고의 UX를 제공합니다:
  - Bonjour를 통한 LAN에서의 자동 디스커버리
  - 게이트웨이가 소유한 페어링 토큰 + ACL
  - 셸 액세스 불필요. 프로토콜 표면을 엄격하고 감사 가능하게 유지 가능
- **SSH**는 범용 대체 수단으로 남아 있습니다:
  - SSH 액세스가 있는 곳이라면 어디서나 작동 (관련 없는 네트워크 간에도)
  - 멀티캐스트/mDNS 문제에도 견딤
  - SSH 외에 새로운 인바운드 포트가 필요 없음

## 디스커버리 입력 (클라이언트가 게이트웨이 위치를 알아내는 방법)

### 1) Bonjour / mDNS (LAN 전용)

Bonjour는 최선의 노력이며 네트워크를 넘지 않습니다. "동일 LAN" 편의를 위해서만 사용됩니다.

목표 방향:

- **게이트웨이**는 Bonjour를 통해 WS 엔드포인트를 광고합니다.
- 클라이언트는 탐색하여 "게이트웨이 선택" 목록을 표시한 다음 선택한 엔드포인트를 저장합니다.

문제 해결 및 비콘 세부 정보: [Bonjour](/gateway/bonjour).

#### 서비스 비콘 세부 정보

- 서비스 유형:
  - `_openclaw-gw._tcp` (게이트웨이 전송 비콘)
- TXT 키 (비밀 아님):
  - `role=gateway`
  - `lanHost=<hostname>.local`
  - `sshPort=22` (또는 광고되는 포트)
  - `gatewayPort=18789` (게이트웨이 WS + HTTP)
  - `gatewayTls=1` (TLS가 활성화된 경우에만)
  - `gatewayTlsSha256=<sha256>` (TLS가 활성화되고 지문을 사용할 수 있는 경우에만)
  - `canvasPort=18793` (기본 캔버스 호스트 포트; `/__openclaw__/canvas/` 제공)
  - `cliPath=<path>` (선택 사항; 실행 가능한 `openclaw` 진입점 또는 바이너리의 절대 경로)
  - `tailnetDns=<magicdns>` (선택적 힌트; Tailscale을 사용할 수 있을 때 자동 감지됨)

비활성화/재정의:

- `OPENCLAW_DISABLE_BONJOUR=1`은 광고를 비활성화합니다.
- `~/.openclaw/openclaw.json`의 `gateway.bind`는 게이트웨이 바인드 모드를 제어합니다.
- `OPENCLAW_SSH_PORT`는 TXT에 광고되는 SSH 포트를 재정의합니다 (기본값 22).
- `OPENCLAW_TAILNET_DNS`는 `tailnetDns` 힌트를 게시합니다 (MagicDNS).
- `OPENCLAW_CLI_PATH`는 광고되는 CLI 경로를 재정의합니다.

### 2) Tailnet (크로스 네트워크)

런던/비엔나 스타일 설정의 경우 Bonjour는 도움이 되지 않습니다. 권장되는 "직접" 대상은:

- Tailscale MagicDNS 이름 (권장) 또는 안정적인 tailnet IP.

게이트웨이가 Tailscale 하에서 실행 중임을 감지할 수 있는 경우, 클라이언트를 위한 선택적 힌트로 `tailnetDns`를 게시합니다 (광역 비콘 포함).

### 3) 수동 / SSH 대상

직접 경로가 없거나 (또는 직접이 비활성화된 경우), 클라이언트는 루프백 게이트웨이 포트를 전달하여 항상 SSH를 통해 연결할 수 있습니다.

[원격 액세스](/gateway/remote) 참조.

## 전송 선택 (클라이언트 정책)

권장 클라이언트 동작:

1. 페어링된 직접 엔드포인트가 구성되어 있고 연결 가능한 경우, 이를 사용합니다.
2. 그렇지 않으면, Bonjour가 LAN에서 게이트웨이를 찾으면 원탭 "이 게이트웨이 사용" 선택을 제공하고 직접 엔드포인트로 저장합니다.
3. 그렇지 않으면, tailnet DNS/IP가 구성된 경우 직접 시도합니다.
4. 그렇지 않으면, SSH로 대체합니다.

## 페어링 + 인증 (직접 전송)

게이트웨이는 노드/클라이언트 승인의 정보 원천입니다.

- 페어링 요청은 게이트웨이에서 생성/승인/거부됩니다 ([게이트웨이 페어링](/gateway/pairing) 참조).
- 게이트웨이는 다음을 적용합니다:
  - 인증 (토큰 / 키쌍)
  - 범위/ACL (게이트웨이는 모든 메서드에 대한 원시 프록시가 아님)
  - 속도 제한

## 구성 요소별 책임

- **게이트웨이**: 디스커버리 비콘을 광고하고, 페어링 결정을 소유하며, WS 엔드포인트를 호스팅합니다.
- **macOS 앱**: 게이트웨이 선택을 돕고, 페어링 프롬프트를 표시하며, SSH를 대체 수단으로만 사용합니다.
- **iOS/Android 노드**: 편의를 위해 Bonjour를 탐색하고 페어링된 게이트웨이 WS에 연결합니다.
