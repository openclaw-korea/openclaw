---
summary: "아웃바운드 채널용 마크다운 형식 지정 파이프라인"
read_when:
  - 아웃바운드 채널용 마크다운 형식 또는 청킹을 변경하는 경우
  - 새 채널 포매터 또는 스타일 매핑을 추가하는 경우
  - 채널 전체의 형식 지정 회귀를 디버깅하는 경우
title: "마크다운 형식 지정"
---

# 마크다운 형식 지정

OpenClaw는 마크다운을 채널별 출력으로 변환하기 전에 공유 중간 표현(IR)으로 변환하여 아웃바운드 마크다운을 형식 지정합니다. IR은 원본 텍스트를 유지하면서 스타일/링크 범위를 포함하므로 청킹과 렌더링이 채널 전체에서 일관성 있게 유지될 수 있습니다.

## 목표

- **일관성:** 한 번의 파싱 단계로 여러 렌더러를 사용합니다.
- **안전한 청킹:** 렌더링 전에 텍스트를 분할하여 인라인 형식이 청크 전체에 걸쳐 끊어지지 않도록 합니다.
- **채널 맞춤:** 마크다운을 다시 파싱하지 않고 동일한 IR을 Slack mrkdwn, Telegram HTML 및 Signal 스타일 범위로 매핑합니다.

## 파이프라인

1. **마크다운을 IR로 파싱합니다**
   - IR은 평문과 스타일 범위(굵게/기울임/취소선/코드/스포일러) 및 링크 범위로 구성됩니다.
   - 오프셋은 UTF-16 코드 단위이므로 Signal 스타일 범위가 해당 API와 일치합니다.
   - 테이블은 채널이 테이블 변환을 옵트인할 때만 파싱됩니다.
2. **IR 청킹(형식 우선)**
   - 청킹은 렌더링 전에 IR 텍스트에 대해 수행됩니다.
   - 인라인 형식은 청크 전체에 걸쳐 분할되지 않습니다. 범위는 청크당 잘립니다.
3. **채널당 렌더링합니다**
   - **Slack:** mrkdwn 토큰(굵게/기울임/취소선/코드), 링크는 `<url|label>` 형식입니다.
   - **Telegram:** HTML 태그(`<b>`, `<i>`, `<s>`, `<code>`, `<pre><code>`, `<a href>`).
   - **Signal:** 평문 + `text-style` 범위. 레이블이 다르면 링크는 `label (url)` 형식이 됩니다.

## IR 예시

입력 마크다운:

```markdown
Hello **world** — see [docs](https://docs.openclaw.ai).
```

IR(개략도):

```json
{
  "text": "Hello world — see docs.",
  "styles": [{ "start": 6, "end": 11, "style": "bold" }],
  "links": [{ "start": 19, "end": 23, "href": "https://docs.openclaw.ai" }]
}
```

## 사용 위치

- Slack, Telegram 및 Signal 아웃바운드 어댑터는 IR에서 렌더링합니다.
- 다른 채널(WhatsApp, iMessage, MS Teams, Discord)은 여전히 평문 또는 자신의 형식 지정 규칙을 사용하며, 청킹 전에 활성화된 경우 마크다운 테이블 변환을 적용합니다.

## 테이블 처리

마크다운 테이블은 채팅 클라이언트 전체에서 일관되게 지원되지 않습니다. `markdown.tables`를 사용하여 채널(및 계정)당 변환을 제어합니다.

- `code`: 테이블을 코드 블록으로 렌더링합니다(대부분의 채널의 기본값).
- `bullets`: 각 행을 글머리 기호 포인트로 변환합니다(Signal + WhatsApp의 기본값).
- `off`: 테이블 파싱 및 변환을 비활성화합니다. 원본 테이블 텍스트가 통과됩니다.

설정 키:

```yaml
channels:
  discord:
    markdown:
      tables: code
    accounts:
      work:
        markdown:
          tables: off
```

## 청킹 규칙

- 청크 제한은 채널 어댑터/설정에서 나오며 IR 텍스트에 적용됩니다.
- 코드 펜스는 채널이 올바르게 렌더링할 수 있도록 뒤에 줄 바꿈이 있는 단일 블록으로 보존됩니다.
- 목록 접두사와 인용문 접두사는 IR 텍스트의 일부이므로 청킹은 접두사 중간에서 분할되지 않습니다.
- 인라인 스타일(굵게/기울임/취소선/인라인 코드/스포일러)은 청크 전체에 걸쳐 분할되지 않습니다. 렌더러는 각 청크 내에서 스타일을 다시 엽니다.

청널 전체의 청킹 동작에 대한 추가 정보가 필요하면 [스트리밍 + 청킹](/concepts/streaming)을 참조하세요.

## 링크 정책

- **Slack:** `[label](url)` -> `<url|label>`; 맨 URL은 그대로 유지됩니다. 자동링크는 이중 링크를 피하기 위해 파싱 중에 비활성화됩니다.
- **Telegram:** `[label](url)` -> `<a href="url">label</a>` (HTML 파싱 모드).
- **Signal:** `[label](url)` -> 레이블이 URL과 일치하지 않으면 `label (url)` 형식입니다.

## 스포일러

스포일러 마커(`||spoiler||`)는 Signal에서만 파싱되며, 여기서 SPOILER 스타일 범위로 매핑됩니다. 다른 채널은 이를 평문으로 처리합니다.

## 채널 포매터를 추가하거나 업데이트하는 방법

1. **한 번만 파싱합니다:** 채널에 적절한 옵션(자동링크, 제목 스타일, 인용문 접두사)과 함께 공유된 `markdownToIR(...)` 도우미를 사용합니다.
2. **렌더링합니다:** `renderMarkdownWithMarkers(...)` 및 스타일 마커 맵(또는 Signal 스타일 범위)을 사용하여 렌더러를 구현합니다.
3. **청킹합니다:** 렌더링 전에 `chunkMarkdownIR(...)` 호출합니다. 각 청크를 렌더링합니다.
4. **어댑터를 연결합니다:** 새 청커와 렌더러를 사용하도록 채널 아웃바운드 어댑터를 업데이트합니다.
5. **테스트합니다:** 형식 테스트를 추가하거나 업데이트하고, 채널이 청킹을 사용하는 경우 아웃바운드 배달 테스트를 추가합니다.

## 일반적인 함정

- Slack 꺾쇠 괄호 토큰(`<@U123>`, `<#C123>`, `<https://...>`)은 보존되어야 합니다. 원본 HTML을 안전하게 이스케이프합니다.
- Telegram HTML은 손상된 마크업을 피하기 위해 태그 외부의 텍스트를 이스케이프해야 합니다.
- Signal 스타일 범위는 UTF-16 오프셋에 따라 다릅니다. 코드 포인트 오프셋을 사용하지 마세요.
- 닫는 마커가 자신의 줄에 표시되도록 울타리가 있는 코드 블록의 뒤에 줄 바꿈을 유지합니다.
