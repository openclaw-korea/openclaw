---
summary: "하트비트와 크론 작업 중 선택하여 자동화를 구성하는 방법에 대한 가이드"
read_when:
  - 반복되는 작업을 일정에 따라 실행하는 방법을 결정할 때
  - 배경 모니터링 또는 알림을 설정할 때
  - 주기적인 확인을 위한 토큰 사용량 최적화할 때
title: "크론 vs 하트비트"
---

# 크론 vs 하트비트: 각각 언제 사용할지

하트비트와 크론 작업 모두 일정에 따라 작업을 실행할 수 있습니다. 이 가이드는 사용 사례에 맞는 최적의 메커니즘을 선택하도록 도와줍니다.

## 빠른 의사결정 가이드

| 사용 사례                             | 권장 방식         | 이유                                      |
| ------------------------------------ | ------------------- | ---------------------------------------- |
| 30분마다 받은편지함 확인             | 하트비트           | 다른 확인 작업과 함께 일괄 처리, 상황 인식 |
| 매일 오전 9시에 보고서 전송       | 크론 (격리됨)     | 정확한 시간이 필요함                      |
| 일정에서 예정된 이벤트 모니터링 | 하트비트           | 주기적 인식에 자연스러움                 |
| 주간 심층 분석 실행               | 크론 (격리됨)     | 독립적인 작업, 다른 모델 사용 가능       |
| 20분 후 알림받기                   | 크론 (메인, `--at`) | 정확한 시간의 일회성 작업                 |
| 배경 프로젝트 상태 확인            | 하트비트           | 기존 주기에 편승                         |

## 하트비트: 주기적 인식

하트비트는 **메인 세션**에서 정기적인 간격(기본값: 30분)으로 실행됩니다. 에이전트가 상황을 확인하고 중요한 내용을 표시하도록 설계되었습니다.

### 하트비트 사용 시기

- **다중 주기적 확인**: 5개의 별도 크론 작업으로 받은편지함, 일정, 날씨, 알림, 프로젝트 상태를 각각 확인하는 대신, 하나의 하트비트가 이 모든 작업을 일괄 처리할 수 있습니다.
- **상황 인식 의사결정**: 에이전트는 전체 메인 세션 컨텍스트를 가지고 있으므로 긴급한 항목과 대기 가능한 항목을 똑똑하게 구분할 수 있습니다.
- **대화 연속성**: 하트비트 실행은 같은 세션을 공유하므로 에이전트는 최근 대화를 기억하고 자연스럽게 후속 조치할 수 있습니다.
- **저오버헤드 모니터링**: 하나의 하트비트로 많은 소규모 폴링 작업을 대체합니다.

### 하트비트 장점

- **다중 확인 일괄 처리**: 하나의 에이전트 턴으로 받은편지함, 일정, 알림을 모두 검토할 수 있습니다.
- **API 호출 감소**: 하나의 하트비트는 5개의 격리된 크론 작업보다 저렴합니다.
- **상황 인식**: 에이전트는 현재 작업 중인 내용을 알고 있어서 우선순위를 정할 수 있습니다.
- **지능형 억제**: 주의가 필요한 내용이 없으면 에이전트는 `HEARTBEAT_OK`를 응답하고 메시지를 전달하지 않습니다.
- **자연스러운 시간**: 큐 로드에 따라 약간 변동하는데, 대부분의 모니터링에는 문제없습니다.

### 하트비트 예제: HEARTBEAT.md 체크리스트

```md
# Heartbeat checklist

- Check email for urgent messages
- Review calendar for events in next 2 hours
- If a background task finished, summarize results
- If idle for 8+ hours, send a brief check-in
```

에이전트는 각 하트비트에서 이 목록을 읽고 모든 항목을 한 번에 처리합니다.

### 하트비트 설정

```json5
{
  agents: {
    defaults: {
      heartbeat: {
        every: "30m", // interval
        target: "last", // where to deliver alerts
        activeHours: { start: "08:00", end: "22:00" }, // optional
      },
    },
  },
}
```

전체 설정은 [하트비트](/gateway/heartbeat)를 참조하세요.

## 크론: 정확한 일정

크론 작업은 **정확한 시간**에 실행되며 메인 컨텍스트에 영향을 주지 않는 격리된 세션에서 실행될 수 있습니다.

### 크론 사용 시기

- **정확한 시간 필요**: "매주 월요일 오전 9시 정확히 이 내용 전송" (근처 시간이 아닌 정확한 시간)
- **독립적인 작업**: 대화 컨텍스트가 필요하지 않은 작업
- **다른 모델/생각 깊이**: 더 강력한 모델을 필요로 하는 심층 분석
- **일회성 알림**: `--at`을 사용한 "20분 후 알림받기"
- **빈번한/잡음이 많은 작업**: 메인 세션 히스토리를 복잡하게 하는 작업
- **외부 트리거**: 에이전트가 다른 활동 중인지 여부와 관계없이 독립적으로 실행되어야 하는 작업

### 크론 장점

- **정확한 시간**: 타임존 지원이 포함된 5개 필드 크론 표현식
- **세션 격리**: 메인 히스토리를 오염시키지 않고 `cron:<jobId>`에서 실행
- **모델 재정의**: 작업별로 더 저렴하거나 더 강력한 모델 사용 가능
- **전달 제어**: 채널로 직접 전달 가능하며, 기본적으로 메인에 요약본 게시 (설정 가능)
- **에이전트 컨텍스트 불필요**: 메인 세션이 유휴 상태이거나 압축된 상태여도 실행
- **일회성 지원**: 정확한 미래 시간대를 위한 `--at`

### 크론 예제: 일일 아침 브리핑

```bash
openclaw cron add \
  --name "Morning briefing" \
  --cron "0 7 * * *" \
  --tz "America/New_York" \
  --session isolated \
  --message "Generate today's briefing: weather, calendar, top emails, news summary." \
  --model opus \
  --deliver \
  --channel whatsapp \
  --to "+15551234567"
```

이는 정확히 뉴욕 시간 오전 7시에 실행되고, 품질을 위해 Opus를 사용하며, WhatsApp으로 직접 전달됩니다.

### 크론 예제: 일회성 알림

```bash
openclaw cron add \
  --name "Meeting reminder" \
  --at "20m" \
  --session main \
  --system-event "Reminder: standup meeting starts in 10 minutes." \
  --wake now \
  --delete-after-run
```

전체 CLI 참조는 [크론 작업](/automation/cron-jobs)을 참조하세요.

## 의사결정 순서도

```
작업이 정확한 시간에 실행되어야 하는가?
  예 -> 크론 사용
  아니오  -> 계속...

작업이 메인 세션에서 격리되어야 하는가?
  예 -> 크론 사용 (격리됨)
  아니오  -> 계속...

이 작업을 다른 주기적 확인과 함께 일괄 처리할 수 있는가?
  예 -> 하트비트 사용 (HEARTBEAT.md에 추가)
  아니오  -> 크론 사용

일회성 알림인가?
  예 -> --at을 사용한 크론 사용
  아니오  -> 계속...

다른 모델 또는 생각 깊이가 필요한가?
  예 -> 크론 사용 (격리됨, --model/--thinking 포함)
  아니오  -> 하트비트 사용
```

## 둘 다 사용

가장 효율적인 설정은 **둘 다** 사용합니다:

1. **하트비트**는 30분마다 한 번에 받은편지함, 일정, 알림 등 일상적인 모니터링을 처리합니다.
2. **크론**은 정확한 일정(일일 보고서, 주간 검토)과 일회성 알림을 처리합니다.

### 예제: 효율적인 자동화 설정

**HEARTBEAT.md** (30분마다 확인):

```md
# Heartbeat checklist

- Scan inbox for urgent emails
- Check calendar for events in next 2h
- Review any pending tasks
- Light check-in if quiet for 8+ hours
```

**크론 작업** (정확한 시간):

```bash
# Daily morning briefing at 7am
openclaw cron add --name "Morning brief" --cron "0 7 * * *" --session isolated --message "..." --deliver

# Weekly project review on Mondays at 9am
openclaw cron add --name "Weekly review" --cron "0 9 * * 1" --session isolated --message "..." --model opus

# One-shot reminder
openclaw cron add --name "Call back" --at "2h" --session main --system-event "Call back the client" --wake now
```

## 로브스터: 승인 기능이 있는 결정론적 워크플로우

로브스터는 결정론적 실행과 명시적 승인이 필요한 **다단계 도구 파이프라인**을 위한 워크플로우 런타임입니다.
작업이 단일 에이전트 턴 이상이고, 인간 확인 포인트가 있는 재개 가능한 워크플로우를 원할 때 사용하세요.

### 로브스터가 적합한 경우

- **다단계 자동화**: 일회성 프롬프트가 아닌 고정 도구 호출 파이프라인이 필요합니다.
- **승인 게이트**: 부작용이 승인될 때까지 일시 중지되었다가 재개됩니다.
- **재개 가능한 실행**: 이전 단계를 다시 실행하지 않고 일시 중지된 워크플로우를 계속합니다.

### 하트비트 및 크론과 함께 작동하는 방식

- **하트비트/크론**은 실행이 _언제_ 발생하는지 결정합니다.
- **로브스터**는 실행이 시작되면 _어떤 단계_가 발생하는지 정의합니다.

예약된 워크플로우의 경우, 크론 또는 하트비트를 사용하여 로브스터를 호출하는 에이전트 턴을 트리거합니다.
임시 워크플로우의 경우, 로브스터를 직접 호출합니다.

### 운영 참고사항 (코드에서)

- 로브스터는 **로컬 서브프로세스**(`lobster` CLI)로 도구 모드에서 실행되고 **JSON 엔벨로프**를 반환합니다.
- 도구가 `needs_approval`을 반환하면, `resumeToken`과 `approve` 플래그로 재개합니다.
- 도구는 **선택적 플러그인**입니다. `tools.alsoAllow: ["lobster"]`를 통해 추가적으로 활성화합니다 (권장).
- `lobsterPath`를 전달하면 **절대 경로**여야 합니다.

전체 사용 및 예제는 [로브스터](/tools/lobster)를 참조하세요.

## 메인 세션 vs 격리된 세션

하트비트와 크론 모두 메인 세션과 상호작용할 수 있지만 다르게 작동합니다:

|         | 하트비트                       | 크론 (메인)              | 크론 (격리됨)        |
| ------- | ------------------------------- | ------------------------ | ---------------------- |
| 세션 | 메인                            | 메인 (시스템 이벤트 경유)  | `cron:<jobId>`         |
| 히스토리 | 공유됨                          | 공유됨                   | 각 실행 시 새로운      |
| 컨텍스트 | 전체                            | 전체                     | 없음 (깨끗한 상태로 시작)    |
| 모델   | 메인 세션 모델              | 메인 세션 모델       | 재정의 가능           |
| 출력  | `HEARTBEAT_OK`가 아니면 전달됨 | 하트비트 프롬프트 + 이벤트 | 메인에 요약본 게시 |

### 메인 세션 크론 사용 시기

`--session main`과 `--system-event`를 사용할 때:

- 알림/이벤트가 메인 세션 컨텍스트에 나타나기를 원합니다.
- 에이전트가 다음 하트비트 중 전체 컨텍스트로 이를 처리하기를 원합니다.
- 별도의 격리된 실행이 없습니다.

```bash
openclaw cron add \
  --name "Check project" \
  --every "4h" \
  --session main \
  --system-event "Time for a project health check" \
  --wake now
```

### 격리된 크론 사용 시기

`--session isolated`를 사용할 때:

- 이전 컨텍스트 없이 깨끗한 상태로 시작합니다.
- 다른 모델 또는 생각 깊이 설정을 사용합니다.
- 출력이 채널로 직접 전달됩니다 (요약본은 여전히 기본적으로 메인에 게시됨).
- 메인 세션 히스토리를 복잡하게 하지 않습니다.

```bash
openclaw cron add \
  --name "Deep analysis" \
  --cron "0 6 * * 0" \
  --session isolated \
  --message "Weekly codebase analysis..." \
  --model opus \
  --thinking high \
  --deliver
```

## 비용 고려사항

| 메커니즘       | 비용 프로필                                            |
| --------------- | ------------------------------------------------------- |
| 하트비트       | N분마다 한 번의 턴; HEARTBEAT.md 크기에 따라 확장 |
| 크론 (메인)     | 다음 하트비트에 이벤트 추가 (격리된 턴 없음)         |
| 크론 (격리됨) | 작업당 전체 에이전트 턴; 더 저렴한 모델 사용 가능      |

**팁**:

- 토큰 오버헤드를 최소화하려면 `HEARTBEAT.md`을 작게 유지하세요.
- 여러 크론 작업 대신 유사한 확인을 하트비트에 일괄 처리합니다.
- 내부 처리만 원할 경우 하트비트에서 `target: "none"`을 사용합니다.
- 일상적인 작업의 경우 더 저렴한 모델로 격리된 크론을 사용합니다.

## 관련 항목

- [하트비트](/gateway/heartbeat) - 전체 하트비트 설정
- [크론 작업](/automation/cron-jobs) - 전체 크론 CLI 및 API 참조
- [시스템](/cli/system) - 시스템 이벤트 + 하트비트 제어
