---
summary: "Clawnet 리팩터: 네트워크 프로토콜, 역할, 인증, 승인, 신원을 통합합니다"
read_when:
  - 노드 + 운영자 클라이언트용 통합 네트워크 프로토콜을 계획 중인 경우
  - 장치 전반에 걸쳐 승인, 페어링, TLS, 현재 상태를 재작업하는 경우
title: "Clawnet 리팩터"
---

# Clawnet 리팩터 (프로토콜 + 인증 통합)

## 안녕하세요

안녕하세요 Peter — 좋은 방향입니다. 이것은 더 간단한 UX와 더 강력한 보안을 가능하게 합니다.

## 목적

다음 사항에 대한 단일하고 엄격한 문서:

- 현재 상태: 프로토콜, 흐름, 신뢰 경계.
- 문제점: 승인, 다중 홉 라우팅, UI 중복.
- 제안된 새로운 상태: 단일 프로토콜, 범위가 있는 역할, 통합된 인증/페어링, TLS 핀닝.
- 신원 모델: 안정적인 ID + 귀여운 슬러그.
- 마이그레이션 계획, 위험, 미해결 질문.

## 목표 (논의에서)

- 모든 클라이언트(Mac 앱, CLI, iOS, Android, 헤드리스 노드)용 단일 프로토콜.
- 모든 네트워크 참가자는 인증 + 페어링됨.
- 역할 명확성: 노드 vs 운영자.
- 사용자가 있는 위치로 라우팅된 중앙 승인.
- 모든 원격 트래픽에 대한 TLS 암호화 + 선택적 핀닝.
- 최소한의 코드 중복.
- 단일 기계는 한 번만 표시되어야 함 (UI/노드 중복 항목 없음).

## 비목표 (명시적)

- 기능 분리 제거 (최소 권한이 필요함).
- 범위 확인 없이 전체 게이트웨이 제어 평면 노출.
- 인증을 인간 레이블(슬러그는 보안이 아닌 상태로 유지)에 의존하도록 만듭니다.

---

# 현재 상태 (현재)

## 두 가지 프로토콜

### 1) 게이트웨이 WebSocket (제어 평면)

- 전체 API 표면: 설정, 채널, 모델, 세션, 에이전트 실행, 로그, 노드 등.
- 기본 바인드: 루프백. SSH/Tailscale을 통한 원격 액세스.
- 인증: `connect`를 통한 토큰/암호.
- TLS 핀닝 없음 (루프백/터널에 의존).
- 코드:
  - `src/gateway/server/ws-connection/message-handler.ts`
  - `src/gateway/client.ts`
  - `docs/gateway/protocol.md`

### 2) Bridge (노드 전송)

- 좁은 허용 목록 표면, 노드 신원 + 페어링.
- TCP를 통한 JSONL; 선택적 TLS + 인증서 지문 핀닝.
- TLS는 발견 TXT에서 지문을 광고합니다.
- 코드:
  - `src/infra/bridge/server/connection.ts`
  - `src/gateway/server-bridge.ts`
  - `src/node-host/bridge-client.ts`
  - `docs/gateway/bridge-protocol.md`

## 현재 제어 평면 클라이언트

- CLI → 게이트웨이 WS via `callGateway` (`src/gateway/call.ts`).
- macOS 앱 UI → 게이트웨이 WS (`GatewayConnection`).
- 웹 제어 UI → 게이트웨이 WS.
- ACP → 게이트웨이 WS.
- 브라우저 제어는 자체 HTTP 제어 서버를 사용합니다.

## 현재 노드

- 노드 모드의 macOS 앱은 게이트웨이 bridge (`MacNodeBridgeSession`)에 연결합니다.
- iOS/Android 앱은 게이트웨이 bridge에 연결합니다.
- 페어링 + 노드별 토큰은 게이트웨이에 저장됩니다.

## 현재 승인 흐름 (exec)

- 에이전트가 게이트웨이를 통해 `system.run`을 사용합니다.
- 게이트웨이가 bridge를 통해 노드를 호출합니다.
- 노드 런타임이 승인을 결정합니다.
- UI 프롬프트는 Mac 앱에 표시됩니다 (노드 == Mac 앱인 경우).
- 노드가 게이트웨이에 `invoke-res`를 반환합니다.
- 다중 홉, UI가 노드 호스트에 연결됨.

## 현재 현재 상태 + 신원

- 게이트웨이 현재 상태 항목 from WS 클라이언트.
- 노드 현재 상태 항목 from bridge.
- Mac 앱은 같은 기계에 대해 두 항목을 표시할 수 있습니다 (UI + 노드).
- 노드 신원은 페어링 저장소에 저장됨; UI 신원은 별도임.

---

# 문제점 / 고통스러운 지점

- 두 가지 프로토콜 스택을 유지해야 함 (WS + Bridge).
- 원격 노드의 승인: 프롬프트가 사용자가 있는 위치가 아니라 노드 호스트에 나타남.
- TLS 핀닝은 bridge에만 존재; WS는 SSH/Tailscale에 의존함.
- 신원 중복: 같은 기계가 여러 인스턴스로 나타남.
- 모호한 역할: UI + 노드 + CLI 기능이 명확히 분리되지 않음.

---

# 제안된 새로운 상태 (Clawnet)

## 단일 프로토콜, 두 가지 역할

역할 + 범위가 있는 단일 WS 프로토콜.

- **역할: 노드** (기능 호스트)
- **역할: 운영자** (제어 평면)
- 운영자용 선택적 **범위**:
  - `operator.read` (상태 + 보기)
  - `operator.write` (에이전트 실행, 전송)
  - `operator.admin` (설정, 채널, 모델)

### 역할 동작

**노드**

- 기능(`caps`, `commands`, 권한)을 등록할 수 있습니다.
- `invoke` 명령(`system.run`, `camera.*`, `canvas.*`, `screen.record` 등)을 받을 수 있습니다.
- 이벤트를 보낼 수 있습니다: `voice.transcript`, `agent.request`, `chat.subscribe`.
- 설정/모델/채널/세션/에이전트 제어 평면 API를 호출할 수 없습니다.

**운영자**

- 범위에 의해 제어되는 전체 제어 평면 API.
- 모든 승인을 받습니다.
- OS 작업을 직접 실행하지 않습니다. 노드로 라우팅합니다.

### 핵심 규칙

역할은 디바이스별이 아니라 연결별입니다. 기기는 두 역할을 별도로 열 수 있습니다.

---

# 통합 인증 + 페어링

## 클라이언트 신원

모든 클라이언트는 다음을 제공합니다:

- `deviceId` (안정적, 기기 키에서 파생됨).
- `displayName` (인간 이름).
- `role` + `scope` + `caps` + `commands`.

## 페어링 흐름 (통합)

- 클라이언트가 인증 없이 연결됩니다.
- 게이트웨이가 해당 `deviceId`에 대한 **페어링 요청**을 생성합니다.
- 운영자가 프롬프트를 받습니다. 승인/거부합니다.
- 게이트웨이가 다음에 바인딩된 자격 증명을 발급합니다:
  - 디바이스 공개 키
  - 역할
  - 범위
  - 기능/명령
- 클라이언트가 토큰을 지속하고, 인증되어 다시 연결합니다.

## 기기 바인딩 인증 (베어러 토큰 재생 방지)

선호: 기기 키쌍.

- 기기가 한 번 키쌍을 생성합니다.
- `deviceId = fingerprint(publicKey)`.
- 게이트웨이가 nonce를 보냅니다. 기기가 서명합니다. 게이트웨이가 확인합니다.
- 토큰은 문자열이 아닌 공개 키로 발급됩니다 (소유 증명).

대체:

- mTLS (클라이언트 인증서): 가장 강력하고, 더 많은 운영 복잡성.
- 단기 베어러 토큰만 임시 단계로 (조기 회전 + 취소).

## 자동 승인 (SSH 휴리스틱)

약한 링크를 피하기 위해 정확히 정의합니다. 다음 중 하나를 선호합니다:

- **로컬 전용**: 클라이언트가 루프백/Unix 소켓을 통해 연결될 때 자동 페어링합니다.
- **SSH를 통한 챌린지**: 게이트웨이가 nonce를 발급합니다. 클라이언트가 SSH로 증명하여 가져옵니다.
- **물리적 현재 상태 윈도우**: 게이트웨이 호스트 UI에서 로컬 승인 후, 짧은 윈도우(예: 10분)에 대해 자동 페어링을 허용합니다.

항상 자동 승인을 기록하고 기록합니다.

---

# 모든 곳의 TLS (개발 + 프로덕션)

## 기존 bridge TLS 재사용

현재 TLS 런타임 + 지문 핀닝 사용:

- `src/infra/bridge/server/tls.ts`
- `src/node-host/bridge-client.ts`의 지문 확인 로직

## WS에 적용

- WS 서버는 동일한 인증서/키 + 지문을 사용하여 TLS를 지원합니다.
- WS 클라이언트는 지문을 핀할 수 있습니다 (선택 사항).
- 발견은 모든 엔드포인트에 대해 TLS + 지문을 광고합니다.
  - 발견은 로케이터 힌트일 뿐입니다. 신뢰 앵커가 아닙니다.

## 이유

- SSH/Tailscale에 대한 기밀성 의존도를 줄입니다.
- 원격 모바일 연결을 기본적으로 안전하게 만듭니다.

---

# 승인 재설계 (중앙 집중식)

## 현재

승인은 노드 호스트(Mac 앱 노드 런타임)에서 발생합니다. 프롬프트가 노드가 실행되는 위치에 나타납니다.

## 제안

승인은 **게이트웨이 호스트**이며, UI는 운영자 클라이언트에 전달됩니다.

### 새로운 흐름

1. 게이트웨이가 `system.run` 의도(에이전트)를 받습니다.
2. 게이트웨이가 승인 레코드를 생성합니다: `approval.requested`.
3. 운영자 UI가 프롬프트를 표시합니다.
4. 승인 결정이 게이트웨이로 전송됩니다: `approval.resolve`.
5. 게이트웨이가 승인된 경우 노드 명령을 호출합니다.
6. 노드가 실행하고 `invoke-res`를 반환합니다.

### 승인 의미론 (강화)

- 모든 운영자에게 브로드캐스트합니다. 활성 UI만 모달을 표시합니다 (다른 항목은 토스트를 받습니다).
- 첫 번째 해상도가 승리합니다. 게이트웨이는 후속 해상도를 이미 해결됨으로 거부합니다.
- 기본 제한 시간: N초 후 거부 (예: 60초), 이유를 기록합니다.
- 해상도는 `operator.approvals` 범위가 필요합니다.

## 이점

- 프롬프트가 사용자가 있는 위치(Mac/휴대폰)에 나타납니다.
- 원격 노드에 대한 일관된 승인.
- 노드 런타임은 헤드리스로 유지됩니다. UI 종속성이 없습니다.

---

# 역할 명확성 예제

## iPhone 앱

- **노드 역할**: 마이크, 카메라, 음성 채팅, 위치, 푸시 투 토크.
- 선택적 **operator.read**: 상태 및 채팅 보기.
- 선택적 **operator.write/admin**: 명시적으로 활성화된 경우에만.

## macOS 앱

- 기본적으로 운영자 역할 (제어 UI).
- "Mac 노드" 활성화시 노드 역할 (system.run, 화면, 카메라).
- 두 연결 모두에 대해 동일한 deviceId → 병합된 UI 항목.

## CLI

- 항상 운영자 역할.
- 하위 명령으로 파생된 범위:
  - `status`, `logs` → read
  - `agent`, `message` → write
  - `config`, `channels` → admin
  - 승인 + 페어링 → `operator.approvals` / `operator.pairing`

---

# 신원 + 슬러그

## 안정적인 ID

인증에 필요합니다. 절대 변경되지 않습니다.
선호:

- 키쌍 지문 (공개 키 해시).

## 귀여운 슬러그 (랍스터 테마)

인간 레이블일 뿐입니다.

- 예: `scarlet-claw`, `saltwave`, `mantis-pinch`.
- 게이트웨이 레지스트리에 저장됨, 편집 가능.
- 충돌 처리: `-2`, `-3`.

## UI 그룹화

역할 전체에 동일한 `deviceId` → 단일 "인스턴스" 행:

- 배지: `operator`, `node`.
- 기능 + 마지막 확인을 표시합니다.

---

# 마이그레이션 전략

## 단계 0: 문서화 + 정렬

- 이 문서를 게시합니다.
- 모든 프로토콜 호출 + 승인 흐름을 인벤토리에 작성합니다.

## 단계 1: WS에 역할/범위 추가

- `connect` 매개변수를 `role`, `scope`, `deviceId`로 확장합니다.
- 노드 역할에 대한 허용 목록 제어를 추가합니다.

## 단계 2: Bridge 호환성

- Bridge를 계속 실행합니다.
- 병렬로 WS 노드 지원을 추가합니다.
- 설정 플래그 뒤에 기능을 제어합니다.

## 단계 3: 중앙 승인

- WS에 승인 요청 + 해석 이벤트를 추가합니다.
- Mac 앱 UI를 업데이트하여 프롬프트 + 응답합니다.
- 노드 런타임이 UI를 프롬프트하지 않습니다.

## 단계 4: TLS 통합

- Bridge TLS 런타임을 사용하여 WS에 대한 TLS 설정을 추가합니다.
- 클라이언트에 핀닝을 추가합니다.

## 단계 5: Bridge 중단

- iOS/Android/Mac 노드를 WS로 마이그레이션합니다.
- Bridge를 폴백으로 유지합니다. 안정적이 되면 제거합니다.

## 단계 6: 기기 바인딩 인증

- 모든 비로컬 연결에 대해 키 기반 신원을 요구합니다.
- 취소 + 회전 UI를 추가합니다.

---

# 보안 참고 사항

- 역할/허용 목록은 게이트웨이 경계에서 시행됩니다.
- 운영자 범위 없이 "완전한" API를 얻는 클라이언트는 없습니다.
- 페어링은 _모든_ 연결에 필요합니다.
- TLS + 핀닝은 모바일의 MITM 위험을 줄입니다.
- SSH 자동 승인은 편의입니다. 여전히 기록되고 취소 가능합니다.
- 발견은 절대 신뢰 앵커가 아닙니다.
- 기능 청구는 플랫폼/유형별로 서버 허용 목록에 대해 검증됩니다.

# 스트리밍 + 큰 페이로드 (노드 미디어)

WS 제어 평면은 작은 메시지에는 좋지만 노드도 다음을 수행합니다:

- 카메라 클립
- 화면 기록
- 오디오 스트림

옵션:

1. WS 바이너리 프레임 + 청킹 + 백프레셔 규칙.
2. 별도 스트리밍 엔드포인트 (여전히 TLS + 인증).
3. 미디어 집약적 명령에 대해 bridge를 더 오래 유지하고 마지막에 마이그레이션합니다.

구현 전에 하나를 선택하여 드리프트를 피합니다.

# 기능 + 명령 정책

- 노드가 보고한 기능/명령은 **청구**로 취급됩니다.
- 게이트웨이는 플랫폼별 허용 목록을 적용합니다.
- 새 명령은 운영자 승인 또는 명시적 허용 목록 변경이 필요합니다.
- 타임스탬프를 사용하여 변경사항을 감사합니다.

# 감사 + 속도 제한

- 로그: 페어링 요청, 승인/거부, 토큰 발급/회전/취소.
- 페어링 스팸 및 승인 프롬프트의 속도 제한.

# 프로토콜 위생

- 명시적 프로토콜 버전 + 오류 코드.
- 재연결 규칙 + 하트비트 정책.
- 현재 상태 TTL 및 마지막 확인 의미론.

---

# 미해결 질문

1. 두 역할을 모두 실행하는 단일 기기: 토큰 모델
   - 역할당 별도 토큰을 권장합니다 (노드 vs 운영자).
   - 동일한 deviceId; 다른 범위; 더 명확한 취소.

2. 운영자 범위 세분화
   - read/write/admin + 승인 + 페어링 (최소 실행 가능).
   - 나중에 기능별 범위를 고려합니다.

3. 토큰 회전 + 취소 UX
   - 역할 변경 시 자동 회전.
   - deviceId + 역할별 취소 UI.

4. 발견
   - 현재 Bonjour TXT를 확장하여 WS TLS 지문 + 역할 힌트를 포함합니다.
   - 로케이터 힌트로만 취급합니다.

5. 교차 네트워크 승인
   - 모든 운영자 클라이언트에 브로드캐스트합니다. 활성 UI가 모달을 표시합니다.
   - 첫 번째 응답이 승리합니다. 게이트웨이가 원자성을 적용합니다.

---

# 요약 (TL;DR)

- 오늘: WS 제어 평면 + Bridge 노드 전송.
- 문제: 승인 + 중복 + 두 스택.
- 제안: 명시적 역할 + 범위가 있는 단일 WS 프로토콜, 통합된 페어링 + TLS 핀닝, 게이트웨이 호스트 승인, 안정적인 기기 ID + 귀여운 슬러그.
- 결과: 더 간단한 UX, 더 강력한 보안, 더 적은 중복, 더 나은 모바일 라우팅.
